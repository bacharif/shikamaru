(function(s,e){typeof exports=="object"&&typeof module<"u"?e(exports,require("starknet")):typeof define=="function"&&define.amd?define(["exports","starknet"],e):(s=typeof globalThis<"u"?globalThis:s||self,e(s.sessions={},s.starknet))})(this,function(s,e){"use strict";var N=Object.defineProperty;var v=(s,e,l)=>e in s?N(s,e,{enumerable:!0,configurable:!0,writable:!0,value:l}):s[e]=l;var C=(s,e,l)=>(v(s,typeof e!="symbol"?e+"":e,l),l);const l="0x31c70ed28f4b0faf39b2f97d8f0a61a36968319c13fe6f2051b8de5a15f3d9b",T="0x2f0026e78543f036f33e26a8f5891b88c58dc1e20cbbfaf0bb53274da6fa568";async function b(n,a){const{result:t}=await a.callContract({contractAddress:n,entrypoint:"isPlugin",calldata:e.stark.compileCalldata({classHash:l})});return!e.number.toBN(t[0]).isZero()}function h({contractAddress:n,selector:a}){return e.hash.computeHashOnElements([T,n,e.typedData.prepareSelector(a)])}function m(n){return new e.merkle.MerkleTree(n.map(h))}function S(n){const{root:a}=m(n.policies);return{...n,root:a}}async function F(n,a){const{expires:t,key:o,policies:r,root:i}=S(n),c=await a.signMessage({primaryType:"Session",types:{Policy:[{name:"contractAddress",type:"felt"},{name:"selector",type:"selector"}],Session:[{name:"key",type:"felt"},{name:"expires",type:"felt"},{name:"root",type:"merkletree",contains:"Policy"}],StarkNetDomain:[{name:"chainId",type:"felt"}]},domain:{chainId:a.chainId},message:{key:o,expires:t,root:r}});return{key:o,policies:r,expires:t,root:i,signature:c}}function I(n){return n&&n.__esModule&&Object.prototype.hasOwnProperty.call(n,"default")?n.default:n}var P=A;function A(n,a){if(!n)throw new Error(a||"Assertion failed")}A.equal=function(a,t,o){if(a!=t)throw new Error(o||"Assertion failed: "+a+" != "+t)};const _=I(P);class w extends e.Account{constructor(t,o,r,i){super(t,o,r);C(this,"merkleTree");this.signedSession=i,this.merkleTree=m(i.policies),_(i.root===this.merkleTree.root,"Invalid session")}async sessionToCall(t,o){return{contractAddress:this.address,entrypoint:"use_plugin",calldata:e.stark.compileCalldata({classHash:l,signer:await this.signer.getPubKey(),expires:t.expires.toString(),root:t.root,proofLength:o[0].length.toString(),...o.reduce((r,i,c)=>({...r,...i.reduce((d,u,f)=>({...d,[`proof${c}:${f}`]:u}),{})}),{}),token1:t.signature[0],token2:t.signature[1]})}}proofCalls(t){return t.map(o=>{const r=h({contractAddress:o.contractAddress,selector:o.entrypoint});return this.merkleTree.getProof(r)})}async extendCallsBySession(t,o){const r=this.proofCalls(t);return[await this.sessionToCall(o,r),...t]}async estimateInvokeFee(t,{nonce:o,blockIdentifier:r}={}){const i=await this.extendCallsBySession(Array.isArray(t)?t:[t],this.signedSession),c=e.number.toBN(o??await this.getNonce()),d=e.number.toBN(e.hash.feeTransactionVersion),u=await this.getChainId(),f={walletAddress:this.address,nonce:e.number.toBN(c),maxFee:e.constants.ZERO,version:d,chainId:u},y=await this.signer.signTransaction(i,f),g=e.transaction.fromCallsToExecuteCalldata(i),p=await super.getInvokeEstimateFee({contractAddress:this.address,calldata:g,signature:y},{version:d,nonce:c},r),x=e.stark.estimatedFeeToMaxFee(p.overall_fee);return{...p,suggestedMaxFee:x}}async execute(t,o=void 0,r={}){const i=await this.extendCallsBySession(Array.isArray(t)?t:[t],this.signedSession),c=e.number.toBN(r.nonce??await this.getNonce());let d="0";if(r.maxFee||r.maxFee===0)d=r.maxFee;else{const{suggestedMaxFee:p}=await this.estimateInvokeFee(Array.isArray(t)?t:[t],{nonce:c});d=p.toString()}const u=e.number.toBN(e.hash.transactionVersion),f={walletAddress:this.address,nonce:c,maxFee:d,version:u,chainId:this.chainId},y=await this.signer.signTransaction(i,f,o),g=e.transaction.fromCallsToExecuteCalldata(i);return this.invokeFunction({contractAddress:this.address,calldata:g,signature:y},{maxFee:d,version:u,nonce:c})}}s.SESSION_PLUGIN_CLASS_HASH=l,s.SessionAccount=w,s.createMerkleTreeForPolicies=m,s.createSession=F,s.default=w,s.preparePolicy=h,s.prepareSession=S,s.supportsSessions=b,Object.defineProperties(s,{__esModule:{value:!0},[Symbol.toStringTag]:{value:"Module"}})});
