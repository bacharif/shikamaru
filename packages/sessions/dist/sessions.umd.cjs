(function(s,e){typeof exports=="object"&&typeof module<"u"?e(exports,require("starknet")):typeof define=="function"&&define.amd?define(["exports","starknet"],e):(s=typeof globalThis<"u"?globalThis:s||self,e(s.sessions={},s.starknet))})(this,function(s,e){"use strict";var P=Object.defineProperty;var N=(s,e,l)=>e in s?P(s,e,{enumerable:!0,configurable:!0,writable:!0,value:l}):s[e]=l;var C=(s,e,l)=>(N(s,typeof e!="symbol"?e+"":e,l),l);const l="0x31c70ed28f4b0faf39b2f97d8f0a61a36968319c13fe6f2051b8de5a15f3d9b",T="0x2f0026e78543f036f33e26a8f5891b88c58dc1e20cbbfaf0bb53274da6fa568";async function b(i,r){const{result:t}=await r.callContract({contractAddress:i,entrypoint:"isPlugin",calldata:e.stark.compileCalldata({classHash:l})});return!e.number.toBN(t[0]).isZero()}function h({contractAddress:i,selector:r}){return e.hash.computeHashOnElements([T,i,e.typedData.prepareSelector(r)])}function m(i){return new e.merkle.MerkleTree(i.map(h))}function S(i){const{root:r}=m(i.policies);return{...i,root:r}}async function x(i,r){const{expires:t,key:n,policies:o,root:a}=S(i),c=await r.signMessage({primaryType:"Session",types:{Policy:[{name:"contractAddress",type:"felt"},{name:"selector",type:"selector"}],Session:[{name:"key",type:"felt"},{name:"expires",type:"felt"},{name:"root",type:"merkletree",contains:"Policy"}],StarkNetDomain:[{name:"chainId",type:"felt"}]},domain:{chainId:r.chainId},message:{key:n,expires:t,root:o}});return{key:n,policies:o,expires:t,root:a,signature:c}}var I=A;function A(i,r){if(!i)throw new Error(r||"Assertion failed")}A.equal=function(r,t,n){if(r!=t)throw new Error(n||"Assertion failed: "+r+" != "+t)};class w extends e.Account{constructor(t,n,o,a){super(t,n,o);C(this,"merkleTree");this.signedSession=a,this.merkleTree=m(a.policies),I(a.root===this.merkleTree.root,"Invalid session")}async sessionToCall(t,n){return{contractAddress:this.address,entrypoint:"use_plugin",calldata:e.stark.compileCalldata({classHash:l,signer:await this.signer.getPubKey(),expires:t.expires.toString(),root:t.root,proofLength:n[0].length.toString(),...n.reduce((o,a,c)=>({...o,...a.reduce((d,u,f)=>({...d,[`proof${c}:${f}`]:u}),{})}),{}),token1:t.signature[0],token2:t.signature[1]})}}proofCalls(t){return t.map(n=>{const o=h({contractAddress:n.contractAddress,selector:n.entrypoint});return this.merkleTree.getProof(o)})}async extendCallsBySession(t,n){const o=this.proofCalls(t);return[await this.sessionToCall(n,o),...t]}async estimateInvokeFee(t,{nonce:n,blockIdentifier:o}={}){const a=await this.extendCallsBySession(Array.isArray(t)?t:[t],this.signedSession),c=e.number.toBN(n??await this.getNonce()),d=e.number.toBN(e.hash.feeTransactionVersion),u=await this.getChainId(),f={walletAddress:this.address,nonce:e.number.toBN(c),maxFee:e.constants.ZERO,version:d,chainId:u},y=await this.signer.signTransaction(a,f),g=e.transaction.fromCallsToExecuteCalldata(a),p=await super.getInvokeEstimateFee({contractAddress:this.address,calldata:g,signature:y},{version:d,nonce:c},o),F=e.stark.estimatedFeeToMaxFee(p.overall_fee);return{...p,suggestedMaxFee:F}}async execute(t,n=void 0,o={}){const a=await this.extendCallsBySession(Array.isArray(t)?t:[t],this.signedSession),c=e.number.toBN(o.nonce??await this.getNonce());let d="0";if(o.maxFee||o.maxFee===0)d=o.maxFee;else{const{suggestedMaxFee:p}=await this.estimateInvokeFee(Array.isArray(t)?t:[t],{nonce:c});d=p.toString()}const u=e.number.toBN(e.hash.transactionVersion),f={walletAddress:this.address,nonce:c,maxFee:d,version:u,chainId:this.chainId},y=await this.signer.signTransaction(a,f,n),g=e.transaction.fromCallsToExecuteCalldata(a);return this.invokeFunction({contractAddress:this.address,calldata:g,signature:y},{maxFee:d,version:u,nonce:c})}}s.SESSION_PLUGIN_CLASS_HASH=l,s.SessionAccount=w,s.createMerkleTreeForPolicies=m,s.createSession=x,s.default=w,s.preparePolicy=h,s.prepareSession=S,s.supportsSessions=b,Object.defineProperties(s,{__esModule:{value:!0},[Symbol.toStringTag]:{value:"Module"}})});
